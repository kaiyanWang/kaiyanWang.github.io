---
layout: article
title: 深度学习框架pytorch
tags: deeplearning
cover: /assets/images/axure/page-single.jpg
---

[pytorch官方教程](https://docs.pytorch.org/tutorials/)

<!--more-->
# 环境搭建

`Conda`（Anaconda公司的包管理器）相比于`pip`（python官方的包管理器）的好处：
- Conda可以创建多个独立虚拟环境，避免版本冲突（pip本身没有环境管理功能，需要搭配venv使用，而Conda将环境管理和包管理集成在同一工具中，操作更加简洁）；
- pip只能管理Python包，无法处理深度学习框架依赖的非Python组件，如CUDA运行库，OpenCV的C++底层库，而Conda可以

`Pytorch`：深度学习框架

### 本地环境配置

第一步：安装Anaconda

第二步：创建虚拟环境
```bash
conda create -n py310 python=3.10  # 创建虚拟环境py310
conda activate py310  # 进入虚拟环境py310
```

第三步：搭建深度学习框架pytorch：查看是否有NVIDIA显卡，并到Pytorch官网下载对应的pytorch-cpu或pytorch-gpu版本（用nvidia-smi查看最高可支持的CUDA版本）[官方文档](https://pytorch.org)

注意：过去在安装pytorch时，通常需要先手动安装CUDA工具包和cuDNN（CUDA即统一计算设备架构，简单说，CUDA 是打通 “CPU 指挥 GPU 干活” 的桥梁，也是让 NVIDIA 显卡从 “只用来玩游戏 / 渲染” 变成 “能做高性能计算” 的核心工具。cuDNN是CUDA的扩展库），但是从pytorch1.0开始，自带了CUDA运行库，不需要手动安装

测试
```python
ipython
import torch
torch.cuda.is_available()  # 输出true
```

第四步：pycharm中使用存在的conda环境：anaconda/Scripts/conda.exe加载环境，选择py310；vscode中下载python和jupyter插件，选择py310环境

### 云服务器环境配置
ssh到云服务器后配置tmux和vim
```bash
scp -P 32579 .bashrc .tmux.conf .vimrc featurize@workspace.featurize.cn:
```
AutoDL平台需要自己下载tmux，并且终端不能识别conda命令，可以在.bash中添加：source "/root/miniconda3/etc/profile.d/conda.sh"

创建虚拟环境
```bash
conda create -n py38 python=3.8  # 创建虚拟环境py38
conda activate py38  # 进入虚拟环境py38
```

安装想要的pytorch版本，[官方文档](https://pytorch.org)
```bash
conda install pytorch==1.13.1 torchvision==0.14.1 torchaudio==0.13.1 pytorch-cuda=11.6 -c pytorch -c nvidia
```

使用本地IDE远程调试
```bash
conda activate py38
which python  # 得到创建的虚拟环境的python解释器位置
```
把pyhton解释器换成远程解释器
File-Settings-Build, Execution, Deployment-Deployment-Mappings可以修改同步文件夹

### 常用的conda命令

虚拟环境管理
```bash
# 查看所有虚拟环境
conda env list  # 查看所有虚拟环境
conda create -n env_name python=3.10  # 创建虚拟环境env_name
conda activate env_name  # 激活虚拟环境env_name
conda env remove -n env_name  # 删除虚拟环境env_name
conda create -n new_env --clone old_env  # 基于old_env创建new_env
```

包管理
```bash
conda list  # 查看当前激活环境的包
conda install numpy=1.24  # 安装到当前环境
conda update numpy  # 更新指定包
conda update --all  # 更新当前环境所有包
conda update conda  # 更新conda自身
conda remove numpy  # 当前环境卸载
conda search tensorflow  # 搜索可用的tensorflow版本
```

配置与其他常用命令
```bash
conda --version  # 查看conda版本
conda env export > environment.yml  # 导出当前环境到yaml文件（分享/备份）
conda env create -f environment.yml  # 从yaml文件创建环境（一键复现）
```

# torch包、torchvision包的使用

[网址](https://docs.pytorch.org/tutorials/beginner/basics/intro.html)

### `dir()`和`help()`函数
`dir(torch)`能输出torch包下所有的包和文件，`help()`输出使用说明

### jupyter
打开终端
```bash
jupyter notebook  # 打开jupyter notebook
jupyter lab  # 打开jupyter lab
```

### 读入图片
```python
# 方法一：读入图片为PIL Image类型
from PIL import Image
img_path1 = "图片路径1"
img_PIL = Image.open(img_path1)
# 方法二：读入图片为numpy.adarray类型
import cv2
img_path2 = "图片路径2"
img_array = cv2.imread(img_path2)
```
无论是PIL Image类型还是numpy.adarray类型，都可以通过ToTensor()转换为tensor类型，PIL Image图片可以通过img_PIL.show()展示图片，numpy.adarray和tensor类型都能用tensorboard展示

### Dataset抽象类
继承之后，需要重写__init__(),__len__(),__getitem__()
```python
from torch.utils.data import Dataset
import os
from PIL import Image


class MyData(Dataset):
    def __init__(self, root_dir, label_name):
        super().__init__()
        self.root_dir = root_dir  # hymenoptera_data/train/
        self.label_name = label_name  # ants
        self.path = os.path.join(self.root_dir, self.label_name)  # hymenoptera_data/train/ants/
        self.img_list = os.listdir(self.path)  # 1.jpg, 2.jpg, ...

    def __len__(self):
        return len(self.img_list)

    def __getitem__(self, idx):
        img_name = self.img_list[idx]
        img_item_path = os.path.join(self.path, img_name)
        img = Image.open(img_item_path)
        label = self.label_name
        return img, label


ants_dataset = MyData("hymenoptera_data/train/", "ants")
bees_dataset = MyData("hymenoptera_data/train/", "bees")

train_dataset = ants_dataset + bees_dataset
```


### tensorboard
```python
from torch.utils.tensorboard import SummaryWriter
import numpy as np
from PIL import Image
from torchvision import transforms

writer = SummaryWriter("logs")
image_path = "hymenoptera_data/train/ants/0013035.jpg"
img_PIL = Image.open(image_path)

img_array = np.array(img_PIL)  # 也可以用cv2.imread(img_path)直接读，也是numpy.adarray类型的
to_tensor = transforms.ToTensor()
img_tensor = to_tensor(img_PIL)

# numpy.ndarray类型必须加dataformats='HWC'，tensor的不用
writer.add_image("img_array", img_array, 1, dataformats='HWC')
writer.add_image("img_tensor", img_tensor, 1)

for i in range(100):
    writer.add_scalar("y=2x", 2 * i, i)

writer.close()
```
打开终端，输入
```bash
tensorboard --logdir=logs --port=自定义端口号  # logdir=事件文件所在文件夹名
```

### torchvision.transforms
```python
from torchvision import transforms
from PIL import Image
import cv2

img_path = "hymenoptera_data/train/ants/0013035.jpg"
img_PIL = Image.open(img_path)  # PIL Image
img_array = cv2.imread(img_path)  # numpy.ndarray (N-dimensional array, N维数组)

# ToTensor()
trans_totensor = transforms.ToTensor()  # 把PIL Image 或 numpy.ndarray (H x W x C)转换成tensor
img_PIL_to_tensor = trans_totensor(img_PIL)
img_array_to_tensor = trans_totensor(img_array)

# Normalize
print(img_PIL_to_tensor[0][0][0])
trans_norm = transforms.Normalize(mean=[0.1, 0.1, 0.1], std=[0.2, 0.2, 0.2])  # input[idx]减均值除以标准差
img_norm = trans_norm(img_PIL_to_tensor)  # 需要tensor类型
print(img_norm[0][0][0])

# Resize
print(img_PIL.size)
img_PIL.show()  # 也可以用tensorboard的add_image，然后在tensorboard里查看
trans_resize = transforms.Resize((512, 512))  # 将PIL Image改为指定尺寸
img_resize = trans_resize(img_PIL)
print(img_resize.size)
img_resize.show()

# Compose
trans_resize2 = transforms.Resize(512)  # 不改变原本的比例
trans_compose = transforms.Compose([trans_resize2, trans_totensor])
img_compose = trans_compose(img_PIL)
```

### torchvision.dataset
https://docs.pytorch.org/vision/stable/index.html

```python
import torchvision.transforms
from torchvision import datasets
from torch.utils.tensorboard import SummaryWriter

datasets_transform = torchvision.transforms.Compose([
    torchvision.transforms.ToTensor()
])

train_dataset = datasets.CIFAR10(root="data", train=True, transform=datasets_transform, download=True)
test_dataset = datasets.CIFAR10(root="data", train=False, transform=datasets_transform, download=True)

print(train_dataset[0])  # 输出：图片类型，class_idx。   图片类型：PIL Image -> tensor
print(train_dataset.classes)  # debug可以看到更多属属性

write = SummaryWriter("test_datasets")
for i in range(10):
    img_tensor, class_idx = train_dataset[i]
    write.add_image("tensor", img_tensor, i)

write.close()
```

### DataLoader
有了数据集之后，通过DataLoader进行取数据，batch_size=4表示每次取4张图
```python
from torch.utils.data import DataLoader
from torchvision import datasets
from torchvision import transforms
from torch.utils.tensorboard import SummaryWriter

test_dataset = datasets.CIFAR10(root="data", train=False, transform=transforms.ToTensor(), download=True)

test_loader = DataLoader(test_dataset, 4, False, num_workers=0, drop_last=False)

# test_dataset中的第一张图片
img, target = test_dataset[0]
print(img.shape, target)

# DataLoader每次取4张
write = SummaryWriter("test_DataLoader")

for data in test_loader:
    imgs, targets = data
    print(imgs.shape, targets)
    write.add_images("test_dataset", imgs, 0)
    break

write.close()
```

### nn.Module抽象类
所有神经网络模块的基类，继承之后，需要重写__init__(), forward()
```python
from torch import nn
import torch

class MyNet(nn.Module):
    def __init__(self):
        super().__init__()

    def forward(self, input):
        output = input + 1
        return output

myNet = MyNet()
input = torch.tensor(1.0)
output = myNet(input)  # 等价于output = myNet.forward(input)
print(output)
```

# 标准流程

### 数据准备（Data Loading）：Dataset和DataLoader

### 模型搭建（Model Building）

### 损失函数（Loss Function）：分类问题用交叉熵损失（CrossEntropyLoss），回归问题用均方误差损失（MSELoss）

### 优化器（Optimizer）：Adam优化器。optimizer.zero_grad()，optimizer_backward()，optimizer.step()

### 训练循环（Training Loop）：写个for循环，把上面四个步骤串起来


# 论文复现

### 论文及代码查询

[谷歌学术](https://scholar.google.com/)，[paperwithcode](https://huggingface.co/papers/trending)，[x-mol](https://www.x-mol.com/)

### 环境搭建

#### step1 克隆项目
```bash
git clone XXX
```

#### step2 创建和激活虚拟环境
如果有environment.yml跳过step2
```bash
conda create -n ENV_NAME
conda activate ENV_NAME
```
#### step3 下载项目需要的包

如果是requirements.txt
```bash
pip install -r requirements.txt
```

如果是environment.yml
```bash
conda env create -f environment.yml  # 从yaml文件创建环境（一键复现）
```

#### step4 检查pytorch包
```python
import torch
print(torch.cuda.is_available())
```
检查step3下载的pytorch包是否是gpu版本的，如果不是，到pytorch官网下载gpu版本的