---
layout: article
title: python
tags: CS
cover: /assets/images/axure/page-single.jpg
---

python官方教程：https://docs.python.org/zh-cn/3.14/tutorial/index.html
<!--more-->

在 Linux/macOS 等系统中，通过python3进入python解释器（默认的python是python2），而 Windows 下通常用python命令。

在Linux中添加可执行权限（chmod +x 文件名.py）后用`./`运行，并且使用utf-8编码：
```python
#! /usr/bin/env python3
#-*- conding: utf-8 -*-
```

直接用python3解释器运行
```bash
python3 文件名.py
```

`ipython3`：交互式的python3，和python3相比，有高亮，支持代码补全，交互模式下，上次输出的表达式会赋给变量 _

python中`/`是浮点数运算，`//`是整数运算（python是向下取整，c++是向0取整）


# 类、异常处理、模块、包的管理、虚拟环境

### 1. 类

类可以将变量、函数打包在一起，让代码在逻辑上更加清晰。类名称一般采用驼峰命名法，函数一般采用下划线命名法。类中函数的第一个参数都是 `self`，用来调用类本身的变量和函数。当调用类中函数的时候，第一个参数 `self` 不需要自己传递，Python会自动传递这个参数。


#### 1.1 类的定义
```python
class Hero:
    hero_count = 0  # 类变量

    def __init__(self, name, level=10):  # 构造函数
        self.name = name
        self.level = level
        print("Hero %s has been created." % name)
        Hero.hero_count += 1

    def __str__(self):  # 定义str()函数的效果
        return "Hero: %s" % self.name

    def greet(self):  # 问候
        print("%s: Hi!" % self.name)

    def move(self):  # 移动
        print("%s: Move!" % self.name)

    def get_level(self):  # 获取这个英雄的等级
        return self.level

    def next_level(self):
        return self.get_level() + 1  # 调用类中的其他函数


zeus = Hero("Zeus")
athena = Hero("Athena", 6)
zeus.greet()
athena.move()
print(zeus.name, athena.get_level(), athena.next_level())
print(str(zeus), athena)  # str(zeus)等价于zeus.__str__()
print(Hero.hero_count, zeus.hero_count, athena.hero_count)  # 习惯上用类来访问类变量，即：Hero.hero_count
```


### 1.2 类变量和实例变量
每个类可以创建任意多实例。例如上面的 `Hero` 类，可以创建 `zeus` 和 `athena` 等实例。
- 类变量由所有实例共享，一般通过类名访问，例如 `Hero.hero_count`。
- 实例变量与每个具体的实例绑定，一般通过具体实例来访问，例如 `zeus.name`。


### 1.3 类的继承
子类可以继承父类的变量和函数。
- `self` 可以调用自身和父类中的变量和函数，`super()` 可以调用父类中的函数。
- 如果子类和父类的变量或函数重名，优先使用子类的变量和函数。

```python
class Zeus(Hero):
    hero_name = "Zeus"

    def __init__(self, level):
        super().__init__(Zeus.hero_name, level)  # 通过super()调用父类的构造函数

    def greet(self):
        print("%s: Hi!(from child class)" % self.name)  # 使用的是父类的`name`


class Athena(Hero):
    hero_name = "Athena"

    def __init__(self, level):
        super().__init__(Athena.hero_name, level)  # 通过super()调用父类的构造函数

    def greet(self):
        print("%s: Hi!(from child class)" % self.name)  # 使用的是父类的`name`


zeus = Zeus(6)
athena = Athena(8)
print(zeus.name, athena.level, Hero.hero_count)
print(str(zeus), str(athena))
zeus.greet()
athena.greet()
print(zeus.next_level())
```
### 2. 异常处理
当某段代码出现异常时，代码会被终止。此时如果不想让代码终止，可以用 `try ... except ...` 语句来处理异常。


#### 示例1：将字符串转化成整数时的异常处理
```python
s = input()
try:  # 用try把可能让程序崩溃的代码括起来，程序不会停止，try里面的如果出错则跳到except里，不出错则不进到except
    x = int(s)
    print(x)
except Exception as e:
    print(e)

print("Finished!")
```


#### 示例2：除以0时的异常处理
```python
x, y = map(int, input().split())
try:
    z = x / y
    print(z)
except Exception as e:
    print(e)

print("Finished!")
```
输出报错信息
```python
x, y = map(int, input().split())
try:
    z = x / y
    print(z)
except Exception as e:
    from traceback import print_exc
    print_exc()

print("finished")
```

### 3. 模块（包）
当项目的逻辑越来越复杂时，把所有代码写到一个文件中会相当不方便。
此时就可以将不同代码放到不同的模块中。所有模块通过文件夹和文件组织成树的形式。

自定义模块时的每个文件夹中需要包含一个空 `__init__.py` 文件，用来让Python识别出这是一个模块。

标准写法
```python 
from 文件夹.文件 import 类/函数
```

### 4. 包的管理
写项目时，不会所有代码都自己实现，会用到很多网络上现成的包（模块）。


#### 4.1 通过命令行管理
安装包：
```bash
pip3 install pygame --user  # --user 参数的作用是：将包安装到当前系统用户的专属路径（而非系统全局路径），避免影响其他用户。
```
升级包：
```bash
pip3 install pygame --user --upgrade
```
删除包：
```bash
pip3 uninstall pygame
```

#### 4.2 通过IDE的图形化界面管理或界面下方的Python Packages

### 5. 虚拟环境
每个虚拟环境主要用来存放一系列不同版本的包。

在Windows或Mac下开发时，一台电脑上可能会有多个Python项目，不同项目可能会依赖不同版本的包，为了不让不同项目之间产生冲突，可以将每个项目放到单独的虚拟环境中。

虚拟环境主要用于本地开发，在云端Linux服务器上部署项目时，一般采用docker来管理环境，不需要使用虚拟环境`env`。