---
title: Linux
tags: CS
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
    src: /assets/images/blogs/Linux.jfif
---

Linux根目录下核心文件夹的**英文全称**及对应含义如下：
1.  **/bin** → **Binary**：存放二进制可执行命令
2.  **/sbin** → **Superuser Binary**：存放超级用户（root）专用的二进制命令
3.  **/etc** → **Etcetera**：字面意为“等等”，引申为系统配置文件集合
4.  **/home** → **Home**：普通用户的家目录
5.  **/root** → **Root**：超级用户root的家目录
6.  **/usr** → **Unix System Resources**：早期为 *User*，现定义为Unix系统资源目录
7.  **/var** → **Variable**：存放可变数据（日志、缓存等动态文件）
8.  **/tmp** → **Temporary**：临时文件目录
9.  **/dev** → **Device**：设备文件目录
10. **/proc** → **Process**：进程与系统信息的虚拟目录
11. **/sys** → **System**：与内核交互的系统硬件虚拟目录
12. **/mnt** → **Mount**：临时挂载外部文件系统的目录
13. **/media** → **Media**：自动挂载移动介质（U盘、光盘）的目录
14. **/opt** → **Optional**：可选安装的第三方软件目录
15. **/srv** → **Service**：存放服务（Web/FTP）所需的数据
16. **/lost+found** → **Lost and Found**：文件系统修复时找回的丢失文件目录
17. **/lib** → **Library**：系统启动核心库目录
<!--more-->

# 1 常用文件管理命令

`.` 当前目录

`..` 上一级目录

`~` 家目录，当前登录的用户是**root 用户（超级管理员）**，pwd的结果为/root，而普通用户**wky**，pwd的结果为/home/wky。输入以下命令即可查看当前登录用户：

```bash
whoami  # 若输出“root”，说明当前是root用户；若输出“wky”，则是普通用户
```

若想切换到普通用户`wky`的家目录：先确认系统中是否存在

```bash
id wky  # 若提示“no such user”，需先创建用户：useradd -m wky（-m会自动创建/home/wky目录）
```

```bash
su - wky  # 切换用户并自动进入/home/wky
```

1、常用命令介绍

> `ctrl+c`：取消命令，并且换行
>
> `ctrl+u`：清空本行命令
>
> `ctrl+insert`：复制；`shift+insert`：粘贴
>
> `history`：输出使用过的命令
>
> `tab`键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项
>
> `ls`：列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件
>
> `pwd`：显示当前路径
>
> `cd XXX`：进入XXX目录下，cd ..返回上层目录，cd -返回上次所在的目录
>
> `cp XXX YYY`：将XXX文件复制到YYY，YYY路径可以和XXX相同
>
> `mkdir XXX`：创建目录XXX
>
> `rm XXX`：删除普通目录，rm XXX -r：删除文件夹
>
> `mv XXX YYY`：将XXX文件移动到YYY，路径可不变，重命名也是用这个命令
>
> `touch XXX`：创建一个文件
>
> `cat XXX`：展示文件XXX中的内容
>
> `scp XXX YYY`：将本地的XXX上传到云服务器YYY路径（scp  D:\test.txt   root@39.99.43.230:/root/），从云端下载同理，注意需要该命令在本地电脑终端执行

# 2 tmux和vim

### 2.1 tmux

tmux原本的前缀键为`ctrl+b`，通过配置改为`ctrl+a`

**功能**：(1)分屏；(2)运行断开terminal连接后，继续运行进程

**结构**：一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane

**操作**：

> （1）`tmux`：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框
>
> （2）按下`ctrl+a`后手指松开（前缀键），然后按`%`：将当前pane左右半分为两个pane
>
> （3）按下`ctrl+a`后手指松开，然后按`"`：将当前pane上下半分为两个pane
>
> （4）`ctrl+d`：关闭当前的pane，如果当前window的所有pane均已关闭，则自动关闭window，如果当前session的所有window均已关闭，则自动关闭session
>
> （5）按下`ctrl+a`后手指松开，然后按方向键：切换窗格pane。
>
> - 鼠标切换（需开启鼠标支持）：按前缀键 `Ctrl + b` + `:`，输入 `set -g mouse on` 回车，之后可直接用鼠标点击窗格切换。
>
> （6）按下`ctrl+a`的同时按方向键：调整pane之间分割线的位置。
>
> - 鼠标拖动pane之间的分割线，可以调整pane之间分割线的位置。
>
> （7）按下`ctrl+a`后手指松开，然后按`z`：将当前pane全屏/取消全屏
>
> （8）按下`ctrl+a`后手指松开，然后按`d`：挂起当前session
>
> （9）`tmux a`：打开之前挂起的session
>
> （10）按下`ctrl+a`后手指松开，然后按`s`：选择其他session
>
> - 方向键-上：选择上一项
> - 方向键-下：选择下一项
> - 方向键-右：展开当前项
> - 方向键-左：闭合当前项
>
> （11）按下`ctrl+a`后手指松开，然后按`c`：在当前session中创建新的window
>
> （12）按下`ctrl+a`后手指松开，然后按`w`：选择其他window，操作方式同（10）
>
> （13）按下`ctrl+a`后手指松开，然后按`PageUp`（fn+方向键上）：翻阅当前pane内的内容
>
> - 鼠标滚轮：翻阅当前pane内的内容
>
> （14）在`tmux`中选择文本时，需要按住shift键，然后可以通过`ctrl+insert`和`shift+insert`复制粘贴

### 2.2 vim

**功能**：(1)命令行格式下的文本编辑器；(2)根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能

**模式**：

（1）一般命令模式：默认模式。命令输入方式：按不同字符，进行不同操作，可以复制、粘贴、删除文本等

（2）编辑模式：在一般命令模式里按下i，会进入编辑模式，按ESC会推出编辑模式，返回到一般命令模式

（3）命令行模式：在一般命令模式里按下`:/?`中的任意一个，会进入命令行模式。命令行在最下面，可以查找、替换、报错、退出、配置编辑器等。

**操作**：

> `vim 文件名`：如果已有该文件，打开它；如果没有，则创建
>
> `i`：进入编辑模式
>
> `ESC`：进入一般命令模式
>
> `n<Space>`：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符
>
> `G`：光标移动到最后一行；`gg`：光标移动到第一行
>
> `:n`或`nG`：n为数字，光标移动到第n行
>
> `n<Enter>`：n为数字，光标向下移动n行
>
> `/word`：向光标之下寻找第一个值为word的字符串
>
> `?word`：向光标之上寻找第一个值为word的字符串
>
> `n`：重复前一个查找操作；`N`：反向重复前一个查找操作
>
> `:n1,n2s/word1/word2/g`：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2
>
> `:1,$s/word1/word2/g`：在第1行与最后一行之间（全文）寻找word1这个字符串，并将该字符串替换为word2
>
> `:1,$s/word1/word2/gc`：在全文寻找word1这个字符串，并将该字符串替换为word2，且在替换前要求用户确认
>
> `v`：选中文本，按两下`esc`取消选中
>
> `d`：删除选中的文本（本质是剪切）
>
> `dd`：删除当前行（本质是剪切）
>
> `y`：复制选中的文本
>
> `yy`：复制当行
>
> `p`：将复制的数据在光标的下一行/下一个位置粘贴
>
> `u`：撤销；`crtl+r`：反撤销
>
> `大于号>`：将选中的文本整体向右移动
>
> `小于号<`：将选中的文本整体向左移动
>
> `:w`：保存
>
> `:w！`：强制保存
>
> `:q`：退出
>
> `:q！`：强制退出
>
> `:wq`：保存并退出
>
> `:set paste`：设置成粘贴模式，取消代码自动缩进
>
> `:set nopaste`：取消粘贴模式，开启代码自动缩进
>
> `:set nu`：显示行号
>
> `:set nonu`：隐藏行号
>
> `gg=G`：将全文代码格式化（gg回到第一行，=格式化，G到最后一行）
>
> `ggdG`：将全文删除（gg回到第一行，d删除，G到最后一行）
>
> `:noh`： 关闭查找关键词高亮
>
> `ctrl+q`：当vim卡死时，可以取消当前正在执行的命令
>
> `ctrl+a`+`[`：复制，`ctrl+a`+`]`：粘贴
>
> `h` 或 `左箭头键`：光标向左移动一个字符，`j` 或 `向下箭头`：光标向下移动一个字符，` k` 或 `向上箭头`：光标向上移动一个字符，` l `或 `向右箭头`：光标向右移动一个字符， `0 `或 `功能键[Home]`：光标移动到本行开头， `$ `或 `功能键[End]`：光标移动到本行末尾

# 3 shell语法

### 3.1 概论

shell是我们通过命令行与操作系统沟通的语言。shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。Terminal中的命令行可以看成是一个“shell脚本在逐行执行”。

Linux中常见的shell脚本有很多种，常见的有：
- Bourne Shell( `/usr/bin/sh` 或 `/bin/sh` )
- Bourne Again Shell( `/bin/bash` )
- C Shell( `/usr/bin/csh` )
- K Shell( `/usr/bin/ksh` )
- zsh
- ……

Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。文件开头需要写 `#! /bin/bash`，指明bash为脚本解释器。

示例：新建一个 `test.sh` 文件，内容如下：
```bash
#! /bin/bash
echo "Hello World!"
```
运行方式1：用解释器执行
```bash
bash test.sh
```
运行方式2：作为可执行文件
```bash
chmod +x test.sh  # 使脚本具有可执行权限
./test.sh  # 当前路径下执行
/home/wky/test.sh  # 绝对路径下执行
```

### 3.2 注释
单行注释：`#`（和python一样）

多行注释：
```bash
:<<EOF
第一行注释
第二行注释
EOF
```
其中`EOF`可以换成其他任意字符串和大部分特殊字符（如`abc`，`!`）


### 3.3 变量

定义变量，不需要加 `$` 符号，例如：
```bash
name1='yxc'  # 单引号定义字符串
name2="yxc"  # 双引号定义字符串
name3=yxc    # 也可以不加引号，同样表示字符串
```

使用变量，需要加上 `$` 符号，或者 `${}` 符号。花括号是可选的，主要为了帮助解释器识别变量边界。
```bash
name=yxc
echo $name   # 输出yxc
echo ${name} # 输出yxc
echo ${name}acwing  # 输出yxcacwing
```

使用 `readonly` 或者 `declare` 可以将变量变为只读。
```bash
name=yxc
readonly name
declare -r name  # 两种写法均可

name=abc  # 会报错，因为此时name只读
```

删除变量
```bash
unset name
```

变量类型

1、自定义变量（局部变量）：子进程不能访问的变量（`bash`命令进入子进程，`exit`退出）

2、环境变量（全局变量）：子进程可以访问的变量

自定义变量改成环境变量：
```bash
name=wky  # 定义变量
export name  # 第一种方法
declare -x name  # 第二种方法
```
环境变量改为自定义变量
```bash
export name=wky
declare +x name  # 改为自定义变量
```

字符串：字符串可以用单引号，也可以用双引号，也可以不用引号。

单引号与双引号区别：单引号中的内容会原样输出，不会执行、不会取变量；双引号中的内容可以执行、可以取变量
```bash
name=wky  # 不用引号
echo 'hello, ${name}, \"hh\"'  # 单引号字符串，输出：hello, ${name}, \"hh\"
echo 'hello, ${name}, \"hh\"'  # 双引号字符串，输出：hello, wky, "hh"
```
获取字符串长度
```bash
name="wky"
echo ${#name}  # 输出：3
```

提取子串
```bash
name="hello, wky"
echo ${name:0:5}  # 提取下标0开始的5个字符，类似c++里的substr，输出：hello
```
### 3.4 默认变量

文件参数变量：在执行shell脚本时，可以向脚本传递参数。`$1`是第一个参数，`$2`是第二个参数，以此类推。`$0`是文件名（包含路径）

其他参数相关变量：`$#`：代表文件传入的参数个数；`$*`：由所有参数构成的用空格隔开的字符串，如：`"$1 $2"`；`$@`：每个参数分别用双引号括起来的字符串，如：`"$1" "$2"`；`$$`：脚本当前运行的进程ID；`$?`：上一条命令的退出状态（exit code），0表示正常退出，其他值表示错误；`$(command)`：

### 3.5 数组
只支持一维数组，初始化时不需要指明数组大小。数组下标从0开始，数组用小括号表示，元素之间用空格隔开。例如：
```bash
array=(1 abc "abc")   # 都是字符串
array[10]=2  # 也可以直接定义数组中某个元素的值
echo ${array[0]}  # 输出：1

# 读取整个数组
echo ${array[@]}  # 第一种写法
echo ${array[*]}  # 第二种写法

echo ${#array[@]} # 输出：4，array[*]也可以
```

### 3.6 expr命令
`expr`用来求表达式的值，格式为：
```bash
expr 表达式  # 表达式说明：用空格隔开每一项，用反斜杆放在shell特定的字符前面，对包含空格和其他特殊字符的字符串要用引号括起来，expr会在stdout中输出结果
```


字符串表达式

- `length STRING`
  返回 `STRING` 的长度

- `index STRING CHARSET`
  `CHARSET` 中任意单个字符在 `STRING` 中最前面的字符位置，下标从1开始。如果在 `STRING` 中完全不存在 `CHARSET` 的字符，则返回0。

- `substr STRING POSITION LENGTH`
  返回 `STRING` 字符串中从 `POSITION` 开始，长度最大为 `LENGTH` 的子串。如果 `POSITION` 或 `LENGTH` 为负数，0或非数值，则返回空字符串。

```bash
str="hello world"
echo $(expr length "$str")  # 求长度，如果str里没有空格，可以不用双引号，输出：11
echo $(expr index "$str" awd)  # 输出：7
echo $(expr substr "$str" 2 3)  # 下标从1开始，输出：ell
```

整数表达式

`expr` 支持普通的算术操作，算术表达式优先级低于字符串表达式，高于逻辑关系表达式。

- `+ -`
  加减运算。两端参数会转换为整数，如果转换失败则报错。

- `* / %`
  乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错。

- `()`
  可以改该优先级，但需要用反斜杠转义

```bash
a=3
b=4

echo `expr $a + $b`  # 输出7
echo `expr $a - $b`  # 输出-1
echo `expr $a \* $b` # 输出12，*需要转义
echo `expr $a / $b`  # 输出0，整除
echo `expr $a % $b`  # 输出3
echo `expr \( $a + 1 \) \* \( $b + 1 \)`  # 输出20，值为(a + 1) * (b + 1)
```

逻辑关系表达式

- `|`
  如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数（短路原则，和c++中的`||`一样）。

- `&`
  如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参数为0或为空，则不会计算第二个参数（短路原则）。

- `< <= == != >= >`
  比较两端的参数，如果为true，则返回1，否则返回0。`"=="`是`"="`的同义词。`expr`首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。

- `()`
  可以改表优先级，但需要用反斜杠转义

```bash
a=3
b=4

echo `expr $a \> $b`  # 输出0，>需要转义
echo `expr $a '<' $b` # 输出1，也可以将特殊字符用引号引起来
echo `expr $a '>=' $b` # 输出0
echo `expr $a \<\= $b` # 输出1

c=0
d=5

echo `expr $c \& $d` # 输出0
echo `expr $a \& $d` # 输出3
echo `expr $c \| $d` # 输出5
echo `expr $a \| $d` # 输出3
```

### 3.7 read命令

`read` 命令用于从标准输入中读取单行数据。当读到文件结束符时，返回false，exit code为1，否则为0（为0表示正常退出）

- `-p`: 后面可以接提示信息
- `-t`: 后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令

```bash
read name  # 读入name的值
abc  # 标准输入
abc  # 标准输出

read -p "Please input your name: " -t 30 name  # 读入name的值，等待时间30秒
Please input your name: abc  # 标准输入
echo $name  # 输出name的值
abc  # 标准输出
```

### 3.8 echo命令
`echo` 用于输出字符串，在命令行中输入`man echo`可以查看其用法。命令格式：
```bash
echo STRING
```

显示普通字符串
```bash
echo "Hello AC Terminal"
echo Hello AC Terminal  # 引号可以省略
```

显示转义字符
```bash
echo "\"Hello AC Terminal\""  # 注意只能使用双引号，如果使用单引号，则不转义
echo \"Hello AC Terminal\"  # 也可以省略双引号
```

显示变量
```bash
name=wky
echo "My name is $name"  # 输出 My name is wky
```

显示换行
```bash
echo -e "Hi\n"  # -e 开启转义
```

显示不换行
```bash
echo -e "Hi \c"  # -e开启转义 \c 不换行
```

显示结果定向至文件
```bash
echo "Hello World" > output.txt  # 将内容以覆盖的方式输出到output.txt中
```

原样输出字符串，不进行转义或取变量(用单引号)
```bash
name=wky
echo '$name'  # 输出：￥name
```

显示命令的执行效果
```bash
echo `date`  # 也可以是$(date)，输出：Sat Dec 13 08:29:51 PM CST 2025
```

### 3.9 printf命令

### `printf` 命令用于格式化输出，类似于 C/C++ 中的 `printf` 函数。
默认不会在字符串末尾添加换行符。


### 命令格式：
```bash
printf format-string [arguments...]
```


### 用法示例
脚本内容：
```bash
printf "%10d!\n" 123  # 占10位，右对齐
printf "%-10.2f!\n" 123.12321  # 占10位，保留2位小数，左对齐
printf "My name is %s\n" "wky"  # 格式化输出字符串
printf "%d * %d = %d\n" 2 3 `expr 2 \* 3`  # 表达式的值作为参数
```

输出结果：
```bash
        123!
123.12     !
My name is wky
2 * 3 = 6
```

### 3.10 test命令与判断符号[]

逻辑运算符&&和||
- `&&` 表示与，`||` 表示或
- 二者具有短路原则：
  - `expr1 && expr2`：当 `expr1` 为假时，直接忽略 `expr2`
  - `expr1 || expr2`：当 `expr1` 为真时，直接忽略 `expr2`
- 表达式的 `exit code` 为0，表示真；为非零，表示假。（与 C/C++ 中的定义相反）

test命令

在命令行中输入 `man test`，可以查看 `test` 命令的用法。`test` 命令用于判断文件类型，以及对变量做比较。`test` 命令用退出状态 `exit code` 返回结果，而不是使用 `stdout`。0表示真，非0表示假（return 0才表示正常结束）。（`expr`命令使用`stdout`，1表示真）
```bash
test 2 -lt 3  # 2小于3为真，返回值为0
echo $?  # 输出上个命令的返回值，输出0
```

```bash
ls  # 列出当前目录下的所有文件
homework output.txt test.sh tmp
test -e test.sh && echo "exist" || echo "Not exist"  # test -e test.sh为真，所以执行echo "exist"，短路原则，不执行echo "Not exist"，输出：exist
test -e test2.sh && echo "exist" || echo "Not exist"  # test -e test2.sh为假，短路原则，不执行echo "exist"，输出：Not exist
```

文件类型判断

`-e`表示文件是否存在，`-f`表示文件是否为文件，`-d`表示是否为目录
```bash
test -e filename  # 判断文件是否存在
```

文件权限判断

`-r`表示文件是否可读，`-w`表示文件是否可写，`-x`表示文件是否可执行，`-s`表示是否为非空文件
```bash
test -r filename  # 判断文件是否可读
```

整数间的比较

`-eq`表示a是否等于b，`-ne`表示a是否不等于b，`-gt`表示a是否大于b，`-lt`表示a是否小于b，`-ge`表示a是否大于等于b，`-le`表示a是否小于等于b
```bash
test $a -eq $b  # a是否等于b
```

字符串比较

```bash
test -z STRING  # 判断STRING是否为空，如果为空，则返回true
test -n STRING  # 判断STRING是否非空，如果非空，则返回true（-n可以省略）
test str1 == str2  # 判断str1是否等于str2 
test str1 != str2  # 判断str1是否不等于str2
```

多重条件判定

`-a`表示两条件是否同时成立，`-o`表示两条件是否至少一个成立，`!`表示取反。如`test ! -x file`，当file不可执行时，返回true
```bash
test -r filename -a -x filename
```

判断符号[]

`[]` 与 `test` 用法几乎一模一样，更常用于 `if` 语句中。另外`[[]]` 是 `[]` 的加强版，支持的特性更多。
```bash
[ 2 -lt 3 ]  # 为真，返回值为0
echo $?  # 输出上个命令的返回值，输出0
```

```bash
ls  # 列出当前目录下的所有文件，输出：homework output.txt test.sh tmp
[ -e test.sh ] && echo "exist" || echo "Not exist"  # test.sh 文件存在，输出：exist
[ -e test2.sh ] && echo "exist" || echo "Not exist"  # test2.sh 文件不存在，输出：Not exist
```
注意：`[]`内的每一项都要用空格隔开；`[]`内的变量，最好用双引号括起来；`[]`内的常数，最好用单或双引号括起来
```bash
name="abc def"
[ $name == "abc def" ]  # 错误，等价于[ abc def == "abc def" ]，参数太多
[ "$name" == "abc def" ]  # 正确
```

### 3.11 判断语句

**if...then形式（类似于 C/C++ 中的 if-else 语句）**

单层if
```bash
if condition
then
    语句1
    语句2
    ...
fi
```

```bash
a=3
b=4

if [ "$a" -lt "$b" ] && [ "$a" -gt 2 ]
then
    echo $a在范围内
fi  # 输出：3在范围内
```

单层if-else
```bash
if condition
then
    语句1
    语句2
    ...
else
    语句1
    语句2
    ...
fi
```

```bash
a=3
b=4

if ! [ "$a" -lt "$b" ]
then
    echo $a不小于$b
else
    echo $a小于$b
fi  # 输出：3小于4
```

多层if-elif-elif-else
```bash
if condition
then
    语句1
    语句2
    ...
elif condition
then
    语句1
    语句2
    ...
elif condition
then
    语句1
    语句2
    ...
else
    语句1
    语句2
    ...
fi
```

```bash
a=4

if [ $a -eq 1 ]
then
    echo $a等于1
elif [ $a -eq 2 ]
then
    echo $a等于2
elif [ $a -eq 3 ]
then
    echo $a等于3
else
    echo 其他
fi  # 输出：其他
```

**case...esac形式（类似于 C/C++ 中的 switch 语句）**
```bash
case $变量名称 in
    值1)
        语句1
        语句2
        ...
        ;;  # 类似于C/C++中的break
    值2)
        语句1
        语句2
        ...
        ;;
    *)  # 类似于C/C++中的default
        语句1
        语句2
        ...
        ;;
esac
```

```bash
a=4

case $a in
    1)
        echo $a等于1
        ;;
    2)
        echo $a等于2
        ;;
    3)
        echo $a等于3
        ;;
    *)
        echo 其他
        ;;
esac  # 输出：其他
```


### 3.12 循环语句

**for...in...do...done**
```bash
for var in val1 val2 val3
do
    语句1
    语句2
    ...
done
```

```bash
# 输出`a 2 cc`，每个元素一行
for i in a 2 cc
do
    echo $i
done

# 输出当前路径下的所有文件名，每个文件名一行
for file in `ls`
do
    echo $file
done

# 输出1-10
for i in $(seq 1 10)  # 也可用{1..10}，但{1..10}不能在终端直接输出
do
    echo $i
done

# 输出a-z
for i in $(seq a z)  # 也可用{a..z}
do
    echo $i
done
```

**for ((...;...;...)) do...done**
```bash
for ((expression; condition; expression))
do
    语句1
    语句2
    ...
done
```

```bash
# 输出1-10，每个数占一行
for ((i=1; i<=10; i++))
do
    echo $i
done
```

**while...do...done循环**
```bash
while condition
do
    语句1
    语句2
    ...
done
```

```bash
# 文件结束符为Ctrl+d，输入文件结束符后read指令返回false
while read name
do
    echo $name
done
```

**until...do...done循环**

当条件为真时结束（与`while`循环逻辑相反：`while`是条件为真时执行，`until`是条件为真时终止）。
```bash
until condition
do
    语句1
    语句2
    ...
done
```

```bash
# 当用户输入`yes`或者`YES`时结束，否则一直等待读入
until [ "$word" == "yes" ] || [ "$word" == "YES" ]
do
    read -p "Please input yes/YES to stop this program: " word
done
```

**break命令**

作用：跳出当前一层循环。注意与 C/C++ 不同的是：`break` 不能跳出 `case` 语句，`case`中跳出循环是`;;`。

```bash
:<<EOF
该示例每读入非EOF的字符串，会输出一遍1-7。
该程序可以输入 `Ctrl+d` 文件结束符来结束，也可以直接用 `Ctrl+c` 杀掉该进程。
EOF
while read name
do
    for ((i=1;i<=10;i++))
    do
        case $i in
        8)
            break  # 跳出for循环，跳出case是;;
            ;;
        *)
            echo $i
            ;;
        esac
    done
done
```

**continue命令**

作用：跳出当次循环（break是跳出当层循环）。
```bash
for ((i=1;i<=10;i++))
do
    if [ `expr $i % 2` -eq 0 ]
    then
        continue
    fi
    echo $i
done  # 该程序输出1-10中的所有奇数。
```

**死循环的处理方式**

如果可以打开该程序，则输入 `Ctrl+c` 即可。否则可以直接关闭进程：
- 1. 使用 `top` 命令找到进程的PID
- 2. 输入 `kill -9 PID` 即可关掉此进程

### 3.13 函数

**bash中的函数**

bash中的函数类似于C/C++中的函数，但存在差异：
- `return`的返回值是`exit code`（取值0-255，0表示正常结束），而非C/C++中的返回值；
- 若要获取函数的输出结果，可通过`echo`输出到`stdout`，再通过`$(function_name)`获取`stdout`内容；
- 函数的`return`值可通过`$?`获取。

```bash
[function] func_name() {  # function关键字可以省略
    语句1
    语句2
    ...
}
```

```bash
# 不获取return值和stdout值
func() {
    name=wky
    echo "Hello $name"
}

func  # 输出：Hello wky

# 获取return值和stdout值，不写return时，默认return 0。
func() {
    name=wky
    echo "Hello $name"
    return 123
}

output=$(func)
ret=$?

echo "output = $output"  # 输出：output = Hello wky
echo "return = $ret"  # 输出：return = 123
```


**函数的输入参数**

在函数内，`$1`表示第一个输入参数，`$2`表示第二个输入参数，依此类推。注意：函数内的`$0`仍然是文件名，而不是函数名。

```bash
func() {  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + … + 0
    if [ $1 -le 0 ]
    then
        echo 0
        return 0
    fi

    sum=$(func $(expr $1 - 1))
    echo $(expr $sum + $1)
}

echo $(func 10)  # 输出：55
```


### 3.14 exit命令

`exit` 命令用来退出当前 `shell` 进程，并返回一个退出状态；使用 `$?` 可以接收这个退出状态。
- `exit` 命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。
- `exit` 退出状态只能是一个介于 0-255 之间的整数，其中只有 0 表示成功，其它值都表示失败。


创建脚本 `test.sh`，内容如下：
```bash
#!/bin/bash

if [ $# -ne 1 ]  # 如果传入参数个数不等于1，则正常退出；否则非正常退出。
then
    echo "arguments not valid"
    exit 1
else
    echo "arguments valid"
    exit 0
fi
```

执行该脚本：
```bash
chmod +x test.sh
./test.sh wky  # 输出：arguments valid
echo $?  # 传入一个参数，则正常退出，exit code为0，输出：0
./test.sh # 输出：arguments not valid
```

### 3.15 文件重定向

**进程默认文件描述符**

每个进程默认打开3个文件描述符：
- `stdin`（标准输入）：从命令行读取数据，文件描述符为0
- `stdout`（标准输出）：向命令行输出数据，文件描述符为1
- `stderr`（标准错误输出）：向命令行输出数据，文件描述符为2

可以用文件重定向将这三个文件重定向到其他文件中。


**重定向命令列表**

| 命令               | 说明                                     |
|--------------------|------------------------------------------|
| `command > file`   | 将 `stdout` 重定向到 `file` 中           |
| `command < file`   | 将 `stdin` 重定向到 `file` 中            |
| `command >> file`  | 将 `stdout` 以追加方式定向到 `file` 中   |
| `command n> file`  | 将文件描述符 `n` 重定向到 `file` 中      |
| `command n>> file` | 将文件描述符 `n` 以追加方式重定向到 `file` 中 |


**输入和输出重定向**

```bash
echo -e "Hello \c" > output.txt  # 将stdout重定向到output.txt中
echo "World" >> output.txt       # 将字符串追加到output.txt中

read str < output.txt            # 从output.txt中读取字符串
echo $str                        # 输出结果：Hello World
```

**同时重定向stdin和stdout**

创建Bash脚本：
```bash
#!/bin/bash

read a
read b

echo $(expr "$a" + "$b")
```

创建`input.txt`，里面的内容为：
```
3
4
```

执行命令：
```bash
chmod +x test.sh  # 添加可执行权限
./test.sh < input.txt > output.txt  # 从input.txt中读取内容，将输出写入output.txt
cat output.txt  # 查看output.txt中的内容，输出为：7
```

### 3.16 引入外部脚本

类似于 C/C++ 中的 `include` 操作，bash 也可以引入其他文件中的代码。

```bash
. filename  # 方法一，注意点和文件名之间有一个空格
source filename  # 方法二 
```

示例

1. 创建 `test1.sh`，内容为：
```bash
#!/bin/bash

name=wky  # 定义变量name
```

2. 然后创建 `test2.sh`，内容为：
```bash
#!/bin/bash

source test1.sh  # 或 . test1.sh

echo My name is: $name  # 可以使用test1.sh中的变量
```

3. 执行命令：
```bash
chmod +x test2.sh
./test2.sh  # 输出：My name is: wky
```

# 4 ssh

### 4.1 远程登录服务器
```bash
ssh user@hostname  # user: 用户名，hostname: IP地址或域名
ssh user@hostname -p 22  # 使用-p登录某一特定端口，默认登录端口号为22
```
第一次登录时会有提示信息，输入yes，然后回车即可。这样会将该服务器的信息记录在本地的`~/.ssh/known_hosts`文件中。


### 4.2 配置别名

回到本地终端，创建文件 `~/.ssh/config`，然后在文件中输入：
```bash
Host myserver1
    HostName IP地址或域名
    User 用户名

Host myserver2
    HostName IP地址或域名
    User 用户名
```
之后再使用服务器时，可以直接使用别名`myserver1`、`myserver2`。

### 4.3 ssh密钥登录

创建密钥：
```bash
ssh-keygen
```
然后一直回车即可。执行结束后，~/.ssh/目录下会多两个文件：`id_rsa`（私钥），`id_rsa.pub`（公钥），之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。

例如，想免密登录`myserver`服务器：

**方法一**：将公钥中的内容，复制到`myserver`中的`~/.ssh/authorized_keys`文件里。

**方法二**：在本地终端使用如下命令给`myserver`一键添加公钥：
```bash
ssh-copy-id myserver
```
### 4.4 自动化场景

不用登录服务器的终端界面，直接在自己本地电脑上，发一条指令让目标服务器执行，执行结果会实时传回本地。

```bash
ssh user@hostname command  # command：替换成Linux命令，如ls等
```
日常使用省时间，自动化场景不可或缺，是远程服务器运维、开发中最常用的命令之一。

### 4.5 scp传文件

```bash
scp source destination  # 将source路径下的文件复制到destination中

scp source1 source2 destination  #一次复制多个文件

scp -r ~/tmp myserver:/home/acs/  # 将本地家目录中的tmp文件夹复制到myserver服务器中的/home/acs/目录下。

scp -r ~/tmp myserver:homework/  # 将本地家目录中的tmp文件夹复制到myserver服务器中的~/homework/目录下。

scp -r myserver:homework . # 将myserver服务器中的~/homework/文件夹复制到本地的当前路径下。

scp -P 22 source1 source2 destination  # 指定服务器的端口号。注意： scp的-r -P等参数尽量加在source和destination之前。

scp ~/.vimrc ~/.tmux.conf myserver:  # 使用scp配置其他服务器的vim和tmux
```

# 5 git

修改`commit`的时间

```bash
# 1. 重新进入变基模式，编辑该提交
git rebase -i HEAD~4  # 只针对最近4次提交（也可用id，从编号为id的commit开始修改：git rebase -i id~1，如果要从第一次提交开始修改：git rebase -i --root）
# 2. 把 pick 改成 e，保存退出
# 3. 同时修改作者时间和提交者时间
GIT_COMMITTER_DATE="2024-XX-XX 10:00:00" git commit --amend --date="2024-XX-XX 10:00:00"
# 4. 收尾变基
git rebase --continue
# 5. 重新强制推送
git push --force-with-lease origin 分支名
```

### 5.1 git基本概念

工作区：仓库的目录。工作区是独立于各个分支的。

暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。

版本库：存放所有已经提交到本地仓库的代码版本

版本结构：树结构，树中每个节点代表一个代码版本。

### 5.2 设置ssh密钥登录

（1）在本地右键，选择`Git bash`， 进入家目录`cd ~`，生成秘钥：`ssh-keygen`

（2）进入`.ssh`隐藏文件，到公钥文件`id_rsa.pub`取出公钥

（3）点击`gitHub`右上方头像，进入`setting`-`Access`-`SSH and GPG keys`，将公钥粘贴进去

### 5.3 git常用命令
> `git config --global user.name xxx`：设置全局用户名，信息记录在`~/.gitconfig文`件中
>
> `git config --global user.email xxx@xxx.com`：设置全局邮箱地址，信息记录在`~/.gitconfig`文件中
>
> `git init`：将当前目录配置成`git`仓库，信息记录在隐藏的`.git`文件夹中
>
> `git add XX`：将XX文件添加到暂存区，`git add .`：将所有待加入暂存区的文件加入暂存区
>
> `git commit -m "给自己看的备注信息"`：将暂存区的内容提交到当前分支
>
> `git status`：查看仓库状态
>
> `git diff XX`：查看XX文件相对于暂存区修改了哪些内容
>
> `git rm --cached XX`：将文件从仓库索引目录中删掉（`git`不管理XX文件的版本），加回去用`git add XX`
>
> `git log`：查看当前分支的所有版本（根->HEAD路径上的版本）
>
> `git reflog`：查看HEAD指针的移动历史（包括被回滚的版本）
>
> `git reset --hard HEAD^` 或` git reset --hard HEAD~`：将代码库回滚到上一个版本，`git reset --hard HEAD^^`：往上回滚两次，以此类推，`git reset --hard HEAD~100`：往上回滚100个版本
>
> `git reset --hard 版本号`：回滚到某一特定版本
>
> `git remote add origin git@git.acwing.com:xxx/XXX.git`：将本地仓库关联到远程仓库
>
> `git push -u `(第一次需要-u以后不需要)：将当前分支推送到远程仓库（`-u` 是 `--set-upstream` 的缩写，核心作用是 给本地分支和远程分支建立「跟踪关系」）
>
> `git push origin branch_name`：将本地的某个分支推送到远程仓库
>
> `git clone git@git.acwing.com:xxx/XXX.git`：将远程仓库XXX下载到当前目录下
>
> `git branch branch_name`：创建新分支
>
> `git checkout branch_name`：切换到branch_name这个分支，`git checkout -b branch_name`：创建并切换到`branch_name`这个分支
>
> `git branch`：查看所有分支和当前所处分支
>
> `git merge branch_name`：将分支`branch_name`合并到当前分支上
>
> `git branch -d branch_name`：删除本地仓库的branch_name分支
>
> `git push --set-upstream origin branch_name`：设置本地的`branch_name`分支对应远程仓库的`branch_name`分支
>
> `git push -d origin branch_name`：删除远程仓库的branch_name分支
>
> `git pull`：将远程仓库的当前分支与本地仓库的当前分支合并，`git pull origin branch_name`：将远程仓库的branch_name分支与本地仓库的当前分支合并
>
> `git branch --set-upstream-to=origin/branch_name1 branch_name2`：将远程的`branch_name1`分支与本地的`branch_name2`分支对应
>
> `git checkout -t origin/branch_name `：将远程的branch_name分支拉取到本地
>
> `git stash`：将工作区和暂存区中尚未提交的修改存入栈中
>
> `git stash apply`：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素
>
> `git stash drop`：删除栈顶存储的修改
>
> `git stash pop`：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素
>
> `git stash list`：查看栈中所有元素

# 6 thrift

# 7 管道、环境变量与常用命令

7.1 管道

7.2 环境变量

7.3 常用命令

# 8 docker

**镜像（images）**

* `docker pull ubuntu:20.04`：拉取一个镜像

* `docker images`：列出本地所有镜像

* `docker image rm ubuntu:20.04` 或 `docker rmi ubuntu:20.04`：删除镜像ubuntu:20.04

* `docker [container] commit CONTAINER IMAGE_NAME:TAG`：创建某个container的镜像

* `docker save -o ubuntu_20_04.tar ubuntu:20.04`：将镜像`ubuntu:20.04`导出到本地文件`ubuntu_20_04.tar`中

* `docker load -i ubuntu_20_04.tar`：将镜像`ubuntu:20.04`从本地文件`ubuntu_20_04.tar`中加载出来


**容器(container)**

* `docker [container] create -it ubuntu:20.04`：利用镜像ubuntu:20.04创建一个容器。

* `docker ps -a`：查看本地的所有容器

* `docker [container] start CONTAINER`：启动容器

* `docker [container] stop CONTAINER`：停止容器

* `docker [container] restart CONTAINER`：重启容器

* `docker [contaienr] run -itd ubuntu:20.04`：创建并启动一个容器

* `docker [container] attach CONTAINER`：进入容器(先按`Ctrl-p`，再按`Ctrl-q`可以挂起容器，`Ctrl+d`退出并stop容器)

* `docker [container] exec CONTAINER COMMAND`：在容器中执行命令

* `docker [container] rm CONTAINER`：删除容器

* `docker container prune`：删除所有已停止的容器

* `docker export -o xxx.tar CONTAINER`：将容器CONTAINER导出到本地文件xxx.tar中

* `docker import xxx.tar image_name:tag`：将本地文件xxx.tar导入成镜像，并将镜像命名为`image_name:tag`

* `docker export/import`与`docker save/load`的区别：`export/import`会丢弃历史记录和元数据信息，仅保存容器当时的快照状态
`save/load会`保存完整记录，体积更大

* `docker top CONTAINER`：查看某个容器内的所有进程

* `docker stats`：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息

* `docker cp xxx CONTAINER:xxx` 或 `docker cp CONTAINER:xxx xxx`：在本地和容器间复制文件

* `docker rename CONTAINER1 CONTAINER2`：重命名容器

* `docker update CONTAINER --memory 500MB`：修改容器限制

